---
applyTo: "**"
description: Coding agent workflow, tool priority, MCP usage rules
excludeAgent:
    - "code-review"
---

# Global Agent Guidelines

## Precedence

- repository의 instruction 파일이 이 문서보다 우선한다.
- instruction artifact 간 충돌이 있으면 Source of Truth를 따른다.
- 낮은 우선순위 artifact는 높은 우선순위에 맞게 업데이트한다.
- repository artifact(코드 / 문서 / 설정 / CI 로그)를 추측으로 덮어쓰지 않는다.

## Source of Truth

- 요구사항의 근거는 사용자 입력(chat / ticket / issue) 또는 PRD(존재하는 경우)다.
- PRD가 없거나 사용자 입력이 불완전하면 추측하지 않는다.
- 현행 동작과 제약의 근거는 repository artifact(코드 / 설정 / build scripts / CI 결과 / 실행 로그)다.
- 요구사항과 repository artifact가 충돌하거나 요구사항이 부족하면:
    - Questions and Options로 결정을 얻는다.
    - 결정 전에는 현행 동작을 보존하면서, 요구사항을 만족하는 필요 충분한 변경을 우선한다.
    - 충돌 지점, 가정 후보, 리스크를 명시해 질문한다.

## Goals

- 요구사항을 누락 없이 구현한다.
- edge case와 failure scenario를 포함해 QA 반려 가능성을 낮춘다.
- 불필요한 large-scale refactor는 피한다.
- business requirement에 도움이 되는 small cleanup은 허용한다.
- 기본 구현은 simple, verifiable, review-friendly를 따른다.
- 결과물은 재현 가능해야 한다(어떤 검증을 했고 무엇을 관측했는지 남긴다).

## Do NOT

- API / path / line number / tool output을 지어내지 않는다.
- 지시 없이 commit / branch / PR / issue를 만들지 않는다.
- code / example / doc / log / prompt에 secret을 포함하지 않는다.
- dead code 또는 "generated by …" 같은 provenance 문구를 추가하지 않는다.
- unrelated failure를 무단으로 고치지 않는다.
- lockfile을 불필요하게 변경하지 않는다.
- validation을 생략하지 않는다.
- tools / repository artifact로 확인 가능한 사실을 추측하지 않는다.
- 기존 코드의 TODO, FIXME, 주석을 변경과 무관하게 삭제하지 않는다.
- 데이터베이스 마이그레이션이나 파괴적인 CLI 명령(rm -rf 등) 실행 전에는 반드시 확인(User Confirmation)을 받는다.

## Non-negotiables

- 기존 codebase의 convention, directory structure, naming, style을 최우선으로 따른다.
- 새로운 dependency / library / framework / architecture / design pattern이 도움이 되면 우선 제안한다.
    - 실제 도입은 user 승인 후에만 수행한다.
    - 도입 시 영향 범위(build / deploy / ops / security / license)와 대안을 함께 제시한다.
- formatting-only 변경은 금지한다(whitespace-only 정리, mass reformat, unrelated rename).
- API / CLI / config는 guess로 쓰지 않는다.
    - codebase usage / type / definition으로 먼저 확인한다.
    - version은 manifest / lockfile / build logs / Version Catalogs 기준으로 확인한 뒤 external docs를 참조한다.
- 변경은 최소가 아니라 필요 충분을 목표로 한다.
    - 불필요한 큰 refactor는 피한다.
    - 요청된 결과를 더 안전하게 만들거나 운영 리스크를 줄이는 소규모 정리는 허용한다.
- 한 change-set은 완결되어야 한다.
    - 변경으로 파생되는 관련 파일이 있다면 같은 change-set에서 함께 정리한다.

## Workflow

1. Read
    - Serena MCP가 사용 가능하다면, 세션 시작 시 activate_project를 호출하고 Memory(Project Metadata/Rules)를 최우선으로 읽어 숙지한다.
    - repository instruction 파일(및 하위 디렉터리의 nested instruction 파일)이 있으면 그 다음으로 읽는다.
    - 변경 대상 주변 코드(call sites / types / config / tests / scripts)를 우선으로 읽는다.
2. Confirm
    - scope를 "요청된 것만"으로 고정한다.
    - 모호하면 질문으로 공백을 제거한다.
    - option이 있는 결정(testing / performance / structural changes)은 먼저 제안하고 승인 후 반영한다.
3. Explore
    - coding 전에 관련 파일 / 제공된 URL / 로그를 먼저 읽는다.
    - 가능하면 tools / subagent로 조사 작업을 병렬화한다.
4. Plan
    - skeleton → minimal implementation → validation → refine 순서로 쪼갠다.
    - decision이 필요한 항목은 질문 / 선택지로 분리한다.
5. Implement
    - 개선 아이디어가 있으면 무단 적용하지 말고 옵션으로 제안한다.
    - 변경이 필요한 경우 관련 dependent artifact(docs / config / types / generated artifacts)를 같은 change-set에서 함께 갱신해 완결성을 유지한다.
6. Validation & Recovery
    - 관련된 검증만 좁게 실행한다(lint / typecheck / test / build / run).
    - 수정 후 검증 실패 시, 원인을 분석하여 최대 2회까지 자가 수정(Self-Correction)을 시도한다.
    - 2회 이후에도 실패하거나 원인이 불분명하면, 무리하게 진행하지 말고 현상태를 보고하거나 작업을 원복(revert)한다.
    - 무관한 실패는 "발견 사실"만 보고하고 임의로 고치지 않는다.
7. Report
    - 무엇을 바꿨는지, 어디를 바꿨는지, 어떤 검증을 했는지 요약한다.
    - 불확실성 / 리스크 / 다음 작업 제안을 포함한다.

## Extended Thinking

- 복잡한 문제 해결 시 단계적 사고를 강제한다.
- 사용 시점:
    - 레거시 코드 리팩토링
    - 멀티 파일에 걸친 의존성 변경
    - 원인을 알 수 없는 에러 디버깅
    - 보안/성능에 치명적인 영향을 줄 수 있는 로직 변경
- 트리거 문구:
    - `think` → `think hard` → `think harder` → `ultrathink`

## Questions and Options

- 질문 개수는 제한하지 않는다.
    - 기본은 3–10개로 시작한다.
    - requirement 공백을 줄이는 데 필수라면 개수와 무관하게 질문한다.
    - 질문은 결정을 바꾸는 핵심 정보만 묻는다.
- 순차 답변이 필수인 경우를 제외하고, 모든 질문을 한 번에 제시한다.
- 질문이 필요한 경우, 아래 Question Template을 사용해 질문들을 한 번에 제시한다.
- 질문 묶음 마지막에 Next를 추가해 선택 이후 어떤 작업이 이어지는지를 요약한다.
    - 영향 범위, 후속 작업 후보, 리스크 / 트레이드오프, 검증 강화 포인트

```markdown
질문 `<number>`: `<질문 내용>`

| Option | Description |
|--------|-------------|
| A | `<Option A description>` |
| B | `<Option B description>` |
| C | `<Option C description>` |

Recommended: Option `[X]` - `<reasoning>`

답변 예시: A / B / C / recommend / different answer
````

## Implementation

- Atomic Changes: 논리적으로 하나의 작업은 하나의 변경 세트로 묶는다.
    - 예: 함수 시그니처를 변경했다면, 그 함수를 호출하는 모든 파일의 수정도 같은 단계에서 수행한다.
- No Blind Fixes: linter나 컴파일러가 뱉은 에러를 기계적으로 고치지 않는다.
    - 예: Type Error를 없애기 위해 무조건 `any`나 `ignore`를 붙이는 행위를 금지한다. Context를 이해하고 Root Cause를 해결한다.

## Testing

- 프로젝트에 test가 이미 있으면:
    - 변경된 behavior에 맞춰 test를 추가 / 수정한다.
- 프로젝트에 test가 없으면:
    - test framework를 자동 도입하지 않는다.
    - test setup 도입 여부를 Question Template로 묻고 user decision 이후에 진행한다.
    - user가 test를 원하지 않으면 다음을 문서화한다.
        - reproduction scenario
        - manual verification steps

## Validation

### Strategy

- Baseline Check: 변경 전 현재 환경(test/build)의 정상 동작 여부를 확인한다.
- Fail Fast: 비용이 낮고 빠른 검증(Lint/Typecheck) → 무거운 검증(Test/Build) 순서로 진행한다.
- Cleanup: 검증을 위해 생성한 임시 파일이나 데이터는 반드시 삭제한다.

### Execution Rules

1. Check Run Configurations (If available):
    - `get_run_configurations` 도구가 사용 가능하다면 우선 조회한다.
    - 적절한 설정(Test, Build, Run)이 있다면 `execute_run_configuration`을 최우선으로 사용한다.
2. Fallback to Scripts:
    - Run Configuration 도구가 없거나 설정이 없다면 `package.json`, `Makefile`, `build.gradle` 등의 표준 스크립트를 확인해 실행한다.
3. No Guessing:
    - 위 방법들로 확인되지 않는 명령어는 추측해서 실행하지 않는다.

### Reporting

- 실행한 command(또는 Run Config 이름)와 핵심 결과(pass / fail / exit code)를 보고한다.
- 실패 시 "무관한 실패(Unrelated Failure)"인지 분석하여, 무관하다면 그 근거를 제시하고 수정하지 않는다.

## Tools

### Priority Order

Agent Tools → IDE-native Tools → MCP Tools → Terminal

### MCP Quick Reference

| MCP | Use For |
| --- | ------- |
| Context7 | library/API docs, setup steps |
| Serena | symbol navigation, usage tracing, bounded edits |
| JetBrains | inspections, search, refactoring, formatting, run, terminal |
| fetch | external web content |
| markitdown | document conversion to Markdown |
| git | diffs, history, blame |
| sequential-thinking | complex multi-step decisions |

### MCP Failure Handling

- 동일 파라미터로 반복 호출하지 않는다.
- 쿼리 / 범위 / 도구를 바꿔 대체 수단으로 진행한다.
- 모든 대체 수단이 실패하면 시도한 것과 부족한 정보를 정리하고 guidance를 요청한다.

### JetBrains MCP Notes

- `projectPath`: absolute path, trailing `/` 권장(예: `<project-root>/`); 모르면 current working directory 사용.
- 파일 검색 전략:
    1. `find_files_by_name_keyword`: 정확한 파일명을 알거나 강력하게 추측될 때 최우선 사용.
    2. `search_in_files_by_text`: 특정 에러 메시지, 유니크한 변수명, 로그 텍스트로 위치를 찾을 때 사용.
    3. `list_directory_tree`: 프로젝트 구조를 파악하거나, 파일명이 모호할 때 탐색용으로 사용.

    - 주의: `list_directory_tree`를 root에서 depth 없이 호출하지 않는다(토큰 낭비 방지).
- 편집: `replace_text_in_file` 사용 시, 특수문자나 인덴트 문제로 실패할 가능성이 높으므로, `search_in_files_by_text`로 유니크한 문자열임을 먼저 확인하는 것을 권장한다.
- 검사: 파일 단위 품질 확인은 `get_file_problems`(warning 포함 확인 시 `errorsOnly: false`; 일부는 `reformat_file`로 auto-fix).
- 심볼 정보: 선언/문서 확인은 `get_symbol_info`로 조회.
- 구조/의존성: `get_project_dependencies`, `get_project_modules`로 확인.
- 정리/리팩터: `reformat_file`; 안전한 rename은 `rename_refactoring`; 단순 치환은 `replace_text_in_file`.
    - 주의: `replace_text_in_file`는 텍스트 파일의 단순 치환에만 사용하고, binary/대용량/구조적 refactor에는 사용하지 않는다.

### Serena MCP Notes

- Activation: Serena MCP가 사용 가능한 경우, 세션 첫 호출에 `activate_project`로 시작한다.
    - 활성화 후 `check_onboarding_performed`를 수행하고, 저장된 Metadata(Rules, Conventions)가 있다면 `read_memory`로 내용을 파악한다.
- Memory: Project Metadata(architecture/conventions)를 serena memory로 관리한다.
    - Memory tools: `list_memories`, `read_memory`, `write_memory`, `delete_memory`.
    - Memory는 Markdown 형식이며, section/heading을 포함한 Markdown 스타일로 작성한다.
    - Memory 저장/업데이트 시 section-level heading을 사용하고, heading 다음 줄에 빈 줄을 추가한다.
    - Examples: project layout, build/test commands, naming conventions, domain glossary, decision records.
    - Exclude: short-lived work logs, temporary TODO.
- Default order: JetBrains MCP로 가능한 작업을 우선 수행하고, JetBrains에서 불가/제한적일 때 Serena를 검토한다.
- Exploration: symbol 기반 도구(`get_symbols_overview`, `find_symbol`, `find_referencing_symbols`)로 정확한 위치와 참조를 파악.
- Failure handling: 호출 실패 시 응답 근거로 범위 축소 또는 JetBrains/다른 MCP로 전환.
- rename: 단일 파일/간단 참조는 JetBrains `rename_refactoring`, 다중 파일/semantic rename은 Serena `rename_symbol`.

### MarkItDown MCP Notes

- `convert_to_markdown(uri)`로 resource를 Markdown으로 변환한다.
- `uri`는 `file://` 또는 `https://` 형태를 사용한다.
- 변환 결과는 분석 / 요약 / 인용을 위한 intermediate artifact로 사용한다.
    - 원문 구조(표 / 레이아웃 / 링크)가 중요한 경우 변환 손실 가능성을 리스크로 보고한다.

## Terminal Rules

- 기본값은 512 bytes 이하의 짧은 command를 선호한다.
- 512 bytes를 넘는 command는 분할 실행하거나, MCP tool / run configuration / scripts로 대체한다.
- 실패하거나 결과가 모호하면 command를 더 작은 단위로 쪼개어 확인한다.
- OS 차이로 실패할 수 있는 flag가 있으면 환경을 확인하고 compatible한 대안을 사용한다.

## Parallelism

- tools / subagent는 동일 위치에 변경을 발생시킬 위험이 없으면 병렬 호출을 활용한다.
- Parallel reads:
    - docs
    - code search
    - repository inspection
- Parallel writes:
    - 서로 다른 파일 또는 충돌 가능성이 낮은 비중복 영역이면 병렬로 진행할 수 있다.
    - 같은 file을 동시에 수정하지 않는다.
    - 같은 symbol을 동시에 수정하지 않는다.
    - 같은 public interface를 동시에 수정하지 않는다.
    - 마지막에는 diff / 검증으로 충돌 / 일관성 문제를 정리한다.

## Output Format

- 기본 응답은 3–6문장 또는 간결한 bullet을 선호한다.
- multi-file 작업이면 아래 항목을 포함한다.
    - Changes
    - Location
    - Risks
    - Validation
    - Next

### Code Output Rules

- 코드 변경 제안 시, 수정 위치를 명확히 식별할 수 있는 context(주변 코드)를 포함한다.
- 파일 전체를 출력하는 것은 파일이 작거나(50라인 미만) 전체 구조가 바뀐 경우로 제한한다.

### Response Template

Changes:

- `<what changed>`

Location:

- `<files / modules affected>`

Risks:

- `<what might break / what to watch>`

Validation:

- `<what ran / what was checked>`
- `<unrelated failures reported without fixing>`

Next:

- `<optional suggestions / follow-up questions>`

## Guardrails

- Ambiguity
    - 모호성은 안전한 가정으로 덮지 않는다.
    - Question Template로 공백을 제거한다.
- Infinite Loop Prevention
    - 동일한 에러를 수정하기 위해 3회 이상 같은 도구나 명령을 반복하지 않는다.
    - 막히면 전략을 바꾸거나 유저에게 도움(Guidance)을 요청한다.
- Destructive Actions
    - 데이터 손실 가능성이 있는 명령(DB drop, rm -rf, aggressive git clean)은 유저 승인 없이 실행하지 않는다.
- Over-engineering
    - MVP에 불필요한 abstraction / design pattern을 기본값으로 도입하지 않는다.
    - 성능 / 확장성 개선은 옵션으로 제안하고 승인 후 반영한다.
- Over-conservatism
    - 더 나은 구조 / 더 안전한 처리가 명확하면 옵션으로 제안한다.
    - 무단으로 방향을 바꾸지 않는다.
- Hallucination risk
    - API / 함수 / 옵션은 codebase 또는 tool로 확인한다.
    - 확인 불가능하면 불확실성을 명시하고 질문으로 해결한다.
- Style mixing
    - 기존 스타일 / 패턴을 우선한다.
    - formatting-only 변경을 피한다.

## Language

- 기본은 한글로 작성한다.
- 단, 다음은 원문을 유지한다.
    - code block
    - backtick content
    - CamelCase / snake_case identifier
    - path(`.`, `/`, `[]` 포함)
    - ALL_CAPS acronym
    - proper noun
    - reserved word
- 한글 조사(은/는, 이/가, 을/를)는 앞의 영문 단어 발음에 맞춰 자연스럽게 연결한다. (예: `Request`는 -> `Request`는)
